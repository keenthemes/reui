{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "sortable-nested",
  "type": "registry:component",
  "dependencies": [
    "sonner",
    "clsx",
    "tailwind-merge",
    "class-variance-authority",
    "@dnd-kit/core",
    "@dnd-kit/sortable",
    "@dnd-kit/utilities",
    "@radix-ui/react-slot",
    "lucide-react"
  ],
  "registryDependencies": ["https://reui.io/r/card.json", "https://reui.io/r/sortable.json"],
  "files": [
    {
      "path": "registry/default/components/sortable/nested.tsx",
      "content": "'use client';\n\nimport { useState } from 'react';\nimport { Card, CardContent } from '@/registry/default/ui/card';\nimport { Sortable, SortableItem, SortableItemHandle } from '@/registry/default/ui/sortable';\nimport { GripVertical } from 'lucide-react';\nimport { toast } from 'sonner';\n\ninterface OptionValue {\n  id: string;\n  value: string;\n}\n\ninterface OptionGroup {\n  id: string;\n  name: string;\n  values: OptionValue[];\n}\n\nconst defaultOptionGroups: OptionGroup[] = [\n  {\n    id: '1',\n    name: 'Colors',\n    values: [\n      { id: '1-1', value: 'White' },\n      { id: '1-2', value: 'Black' },\n      { id: '1-3', value: 'Grey' },\n      { id: '1-4', value: 'Green' },\n    ],\n  },\n  {\n    id: '2',\n    name: 'Sizes',\n    values: [\n      { id: '2-1', value: 'Small' },\n      { id: '2-2', value: 'Medium' },\n      { id: '2-3', value: 'Large' },\n    ],\n  },\n  {\n    id: '3',\n    name: 'Materials',\n    values: [\n      { id: '3-1', value: 'Cotton' },\n      { id: '3-2', value: 'Polyester' },\n      { id: '3-3', value: 'Wool' },\n    ],\n  },\n];\n\nexport default function SortableNested() {\n  const [optionGroups, setOptionGroups] = useState<OptionGroup[]>(defaultOptionGroups);\n\n  const handleParentReorder = (newGroups: OptionGroup[]) => {\n    console.log('ðŸ”´ PARENT REORDERED:', newGroups);\n    setOptionGroups(newGroups);\n\n    toast.success('Option groups reordered successfully!', {\n      description: `${newGroups.map((group, index) => `${index + 1}. ${group.name}`).join(', ')}`,\n      duration: 4000,\n    });\n  };\n\n  const getParentValue = (group: OptionGroup) => group.id;\n  const getChildValue = (value: OptionValue) => value.id;\n\n  const handleChildReorder = (groupId: string, newValues: OptionValue[]) => {\n    console.log('ðŸ”´ CHILD REORDERED:', groupId, newValues);\n    setOptionGroups((prev) => prev.map((group) => (group.id === groupId ? { ...group, values: newValues } : group)));\n\n    toast.success('Values reordered successfully!', {\n      description: `${newValues.map((value, index) => `${index + 1}. ${value.value}`).join(', ')}`,\n      duration: 4000,\n    });\n  };\n\n  return (\n    <div className=\"w-full max-w-4xl mx-auto p-6 space-y-6\">\n      <Sortable\n        value={optionGroups}\n        onValueChange={handleParentReorder}\n        getItemValue={getParentValue}\n        strategy=\"vertical\"\n        className=\"space-y-4\"\n      >\n        {optionGroups.map((group) => (\n          <SortableItem key={group.id} value={group.id}>\n            <Card>\n              <CardContent>\n                {/* Group Header */}\n                <div className=\"flex items-center gap-2 mb-4\">\n                  <SortableItemHandle className=\"text-muted-foreground hover:text-foreground cursor-grab\">\n                    <GripVertical className=\"h-4 w-4\" />\n                  </SortableItemHandle>\n                  <h3 className=\"font-semibold text-base\">{group.name}</h3>\n                </div>\n\n                {/* Option Values - Child Level */}\n                <div className=\"ps-2.5\">\n                  <Sortable\n                    value={group.values}\n                    onValueChange={(newValues) => handleChildReorder(group.id, newValues)}\n                    getItemValue={getChildValue}\n                    strategy=\"vertical\"\n                    className=\"space-y-2\"\n                  >\n                    {group.values.map((value) => (\n                      <SortableItem key={value.id} value={value.id}>\n                        <div className=\"flex items-center gap-2 p-2 border border-border rounded-md\">\n                          <SortableItemHandle className=\"text-muted-foreground hover:text-foreground cursor-grab\">\n                            <GripVertical className=\"h-4 w-4\" />\n                          </SortableItemHandle>\n                          <span className=\"flex-1 text-sm\">{value.value}</span>\n                        </div>\n                      </SortableItem>\n                    ))}\n                  </Sortable>\n                </div>\n              </CardContent>\n            </Card>\n          </SortableItem>\n        ))}\n      </Sortable>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/ui/card.tsx",
      "content": "'use client';\n\nimport * as React from 'react';\nimport { cn } from '@/registry/default/lib/utils';\nimport { cva, type VariantProps } from 'class-variance-authority';\n\n// Define CardContext\ntype CardContextType = {\n  variant: 'default' | 'accent';\n};\n\nconst CardContext = React.createContext<CardContextType>({\n  variant: 'default', // Default value\n});\n\n// Hook to use CardContext\nconst useCardContext = () => {\n  const context = React.useContext(CardContext);\n  if (!context) {\n    throw new Error('useCardContext must be used within a Card component');\n  }\n  return context;\n};\n\n// Variants\nconst cardVariants = cva('flex flex-col items-stretch text-card-foreground rounded-xl', {\n  variants: {\n    variant: {\n      default: 'bg-card border border-border shadow-xs black/5',\n      accent: 'bg-muted shadow-xs p-1',\n    },\n  },\n  defaultVariants: {\n    variant: 'default',\n  },\n});\n\nconst cardHeaderVariants = cva('flex items-center justify-between flex-wrap px-5 min-h-14 gap-2.5', {\n  variants: {\n    variant: {\n      default: 'border-b border-border',\n      accent: '',\n    },\n  },\n  defaultVariants: {\n    variant: 'default',\n  },\n});\n\nconst cardContentVariants = cva('grow p-5', {\n  variants: {\n    variant: {\n      default: '',\n      accent: 'bg-card rounded-t-xl [&:last-child]:rounded-b-xl',\n    },\n  },\n  defaultVariants: {\n    variant: 'default',\n  },\n});\n\nconst cardTableVariants = cva('grid grow', {\n  variants: {\n    variant: {\n      default: '',\n      accent: 'bg-card rounded-xl',\n    },\n  },\n  defaultVariants: {\n    variant: 'default',\n  },\n});\n\nconst cardFooterVariants = cva('flex items-center px-5 min-h-14', {\n  variants: {\n    variant: {\n      default: 'border-t border-border',\n      accent: 'bg-card rounded-b-xl mt-[2px]',\n    },\n  },\n  defaultVariants: {\n    variant: 'default',\n  },\n});\n\n// Card Component\nfunction Card({\n  className,\n  variant = 'default',\n  ...props\n}: React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof cardVariants>) {\n  return (\n    <CardContext.Provider value={{ variant: variant || 'default' }}>\n      <div data-slot=\"card\" className={cn(cardVariants({ variant }), className)} {...props} />\n    </CardContext.Provider>\n  );\n}\n\n// CardHeader Component\nfunction CardHeader({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {\n  const { variant } = useCardContext();\n  return <div data-slot=\"card-header\" className={cn(cardHeaderVariants({ variant }), className)} {...props} />;\n}\n\n// CardContent Component\nfunction CardContent({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {\n  const { variant } = useCardContext();\n  return <div data-slot=\"card-content\" className={cn(cardContentVariants({ variant }), className)} {...props} />;\n}\n\n// CardTable Component\nfunction CardTable({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {\n  const { variant } = useCardContext();\n  return <div data-slot=\"card-table\" className={cn(cardTableVariants({ variant }), className)} {...props} />;\n}\n\n// CardFooter Component\nfunction CardFooter({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {\n  const { variant } = useCardContext();\n  return <div data-slot=\"card-footer\" className={cn(cardFooterVariants({ variant }), className)} {...props} />;\n}\n\n// Other Components\nfunction CardHeading({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {\n  return <div data-slot=\"card-heading\" className={cn('space-y-1', className)} {...props} />;\n}\n\nfunction CardToolbar({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {\n  return <div data-slot=\"card-toolbar\" className={cn('flex items-center gap-2.5', className)} {...props} />;\n}\n\nfunction CardTitle({ className, ...props }: React.HTMLAttributes<HTMLHeadingElement>) {\n  return (\n    <h3\n      data-slot=\"card-title\"\n      className={cn('text-base font-semibold leading-none tracking-tight', className)}\n      {...props}\n    />\n  );\n}\n\nfunction CardDescription({ className, ...props }: React.HTMLAttributes<HTMLDivElement>) {\n  return <div data-slot=\"card-description\" className={cn('text-sm text-muted-foreground', className)} {...props} />;\n}\n\n// Exports\nexport { Card, CardContent, CardDescription, CardFooter, CardHeader, CardHeading, CardTable, CardTitle, CardToolbar };\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "registry/default/ui/sortable.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-explicit-any */\n'use client';\n\nimport * as React from 'react';\nimport { cn } from '@/registry/default/lib/utils';\nimport {\n  defaultDropAnimation,\n  defaultDropAnimationSideEffects,\n  DndContext,\n  DragEndEvent,\n  DragOverEvent,\n  DragOverlay,\n  DragStartEvent,\n  DropAnimation,\n  KeyboardSensor,\n  PointerSensor,\n  UniqueIdentifier,\n  useSensor,\n  useSensors,\n  type DraggableAttributes,\n  type DraggableSyntheticListeners,\n} from '@dnd-kit/core';\nimport {\n  arrayMove,\n  rectSortingStrategy,\n  SortableContext,\n  sortableKeyboardCoordinates,\n  useSortable,\n  verticalListSortingStrategy,\n} from '@dnd-kit/sortable';\nimport { CSS } from '@dnd-kit/utilities';\nimport { Slot } from '@radix-ui/react-slot';\n\ninterface KanbanContextProps<T> {\n  columns: Record<string, T[]>;\n  setColumns: (columns: Record<string, T[]>) => void;\n  getItemId: (item: T) => string;\n  columnIds: string[];\n  activeId: UniqueIdentifier | null;\n  setActiveId: (id: UniqueIdentifier | null) => void;\n  findContainer: (id: UniqueIdentifier) => string | undefined;\n  isColumn: (id: UniqueIdentifier) => boolean;\n}\n\nconst KanbanContext = React.createContext<KanbanContextProps<any>>({\n  columns: {},\n  setColumns: () => {},\n  getItemId: () => '',\n  columnIds: [],\n  activeId: null,\n  setActiveId: () => {},\n  findContainer: () => undefined,\n  isColumn: () => false,\n});\n\nconst ColumnContext = React.createContext<{\n  attributes: DraggableAttributes;\n  listeners: DraggableSyntheticListeners | undefined;\n  isDragging?: boolean;\n  disabled?: boolean;\n}>({\n  attributes: {} as DraggableAttributes,\n  listeners: undefined,\n  isDragging: false,\n  disabled: false,\n});\n\nconst ItemContext = React.createContext<{\n  listeners: DraggableSyntheticListeners | undefined;\n  isDragging?: boolean;\n  disabled?: boolean;\n}>({\n  listeners: undefined,\n  isDragging: false,\n  disabled: false,\n});\n\nconst dropAnimationConfig: DropAnimation = {\n  ...defaultDropAnimation,\n  sideEffects: defaultDropAnimationSideEffects({\n    styles: {\n      active: {\n        opacity: '0.4',\n      },\n    },\n  }),\n};\n\nexport interface KanbanMoveEvent {\n  event: DragEndEvent;\n  activeContainer: string;\n  activeIndex: number;\n  overContainer: string;\n  overIndex: number;\n}\n\nexport interface KanbanRootProps<T> {\n  value: Record<string, T[]>;\n  onValueChange: (value: Record<string, T[]>) => void;\n  getItemValue: (item: T) => string;\n  children: React.ReactNode;\n  className?: string;\n  onMove?: (event: KanbanMoveEvent) => void;\n}\n\nfunction Kanban<T>({ value, onValueChange, getItemValue, children, className, onMove }: KanbanRootProps<T>) {\n  const columns = value;\n  const setColumns = onValueChange;\n  const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);\n\n  const sensors = useSensors(\n    useSensor(PointerSensor, {\n      activationConstraint: {\n        distance: 10,\n      },\n    }),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    }),\n  );\n\n  const columnIds = React.useMemo(() => Object.keys(columns), [columns]);\n\n  const isColumn = React.useCallback((id: UniqueIdentifier) => columnIds.includes(id as string), [columnIds]);\n\n  const findContainer = React.useCallback(\n    (id: UniqueIdentifier) => {\n      if (isColumn(id)) return id as string;\n      return columnIds.find((key) => columns[key].some((item) => getItemValue(item) === id));\n    },\n    [columns, columnIds, getItemValue, isColumn],\n  );\n\n  const handleDragStart = React.useCallback((event: DragStartEvent) => {\n    setActiveId(event.active.id);\n  }, []);\n\n  const handleDragOver = React.useCallback(\n    (event: DragOverEvent) => {\n      if (onMove) {\n        return;\n      }\n\n      const { active, over } = event;\n      if (!over) return;\n\n      if (isColumn(active.id)) return;\n\n      const activeContainer = findContainer(active.id);\n      const overContainer = findContainer(over.id);\n\n      // Only handle moving items between different columns\n      if (!activeContainer || !overContainer || activeContainer === overContainer) {\n        return;\n      }\n\n      const activeItems = columns[activeContainer];\n      const overItems = columns[overContainer];\n\n      const activeIndex = activeItems.findIndex((item: T) => getItemValue(item) === active.id);\n      let overIndex = overItems.findIndex((item: T) => getItemValue(item) === over.id);\n\n      // If dropping on the column itself, not an item\n      if (isColumn(over.id)) {\n        overIndex = overItems.length;\n      }\n\n      const newOverItems = [...overItems];\n      const [movedItem] = activeItems.splice(activeIndex, 1);\n      newOverItems.splice(overIndex, 0, movedItem);\n\n      setColumns({\n        ...columns,\n        [activeContainer]: [...activeItems],\n        [overContainer]: newOverItems,\n      });\n    },\n    [findContainer, getItemValue, isColumn, setColumns, columns, onMove],\n  );\n\n  const handleDragEnd = React.useCallback(\n    (event: DragEndEvent) => {\n      const { active, over } = event;\n      setActiveId(null);\n\n      if (!over) return;\n\n      // Handle item move callback\n      if (onMove && !isColumn(active.id)) {\n        const activeContainer = findContainer(active.id);\n        const overContainer = findContainer(over.id);\n\n        if (activeContainer && overContainer) {\n          const activeIndex = columns[activeContainer].findIndex((item: T) => getItemValue(item) === active.id);\n          const overIndex = isColumn(over.id)\n            ? columns[overContainer].length\n            : columns[overContainer].findIndex((item: T) => getItemValue(item) === over.id);\n\n          onMove({\n            event,\n            activeContainer,\n            activeIndex,\n            overContainer,\n            overIndex,\n          });\n        }\n        return;\n      }\n\n      // Handle column reordering\n      if (isColumn(active.id) && isColumn(over.id)) {\n        const activeIndex = columnIds.indexOf(active.id as string);\n        const overIndex = columnIds.indexOf(over.id as string);\n        if (activeIndex !== overIndex) {\n          const newOrder = arrayMove(Object.keys(columns), activeIndex, overIndex);\n          const newColumns: Record<string, T[]> = {};\n          newOrder.forEach((key) => {\n            newColumns[key] = columns[key];\n          });\n          setColumns(newColumns);\n        }\n        return;\n      }\n\n      const activeContainer = findContainer(active.id);\n      const overContainer = findContainer(over.id);\n\n      // Handle item reordering within the same column\n      if (activeContainer && overContainer && activeContainer === overContainer) {\n        const container = activeContainer;\n        const activeIndex = columns[container].findIndex((item: T) => getItemValue(item) === active.id);\n        const overIndex = columns[container].findIndex((item: T) => getItemValue(item) === over.id);\n\n        if (activeIndex !== overIndex) {\n          setColumns({\n            ...columns,\n            [container]: arrayMove(columns[container], activeIndex, overIndex),\n          });\n        }\n      }\n    },\n    [columnIds, columns, findContainer, getItemValue, isColumn, setColumns, onMove],\n  );\n\n  const contextValue = React.useMemo(\n    () => ({\n      columns,\n      setColumns,\n      getItemId: getItemValue,\n      columnIds,\n      activeId,\n      setActiveId,\n      findContainer,\n      isColumn,\n    }),\n    [columns, setColumns, getItemValue, columnIds, activeId, findContainer, isColumn],\n  );\n\n  return (\n    <KanbanContext.Provider value={contextValue}>\n      <DndContext sensors={sensors} onDragStart={handleDragStart} onDragOver={handleDragOver} onDragEnd={handleDragEnd}>\n        <div data-slot=\"kanban\" data-dragging={activeId !== null} className={cn(className)}>\n          {children}\n        </div>\n      </DndContext>\n    </KanbanContext.Provider>\n  );\n}\n\nexport interface KanbanBoardProps {\n  className?: string;\n  children: React.ReactNode;\n}\n\nfunction KanbanBoard({ children, className }: KanbanBoardProps) {\n  const { columnIds } = React.useContext(KanbanContext);\n\n  return (\n    <SortableContext items={columnIds} strategy={rectSortingStrategy}>\n      <div data-slot=\"kanban-board\" className={cn('grid auto-rows-fr sm:grid-cols-3 gap-4', className)}>\n        {children}\n      </div>\n    </SortableContext>\n  );\n}\n\nexport interface KanbanColumnProps {\n  value: string;\n  className?: string;\n  children: React.ReactNode;\n  disabled?: boolean;\n}\n\nfunction KanbanColumn({ value, className, children, disabled }: KanbanColumnProps) {\n  const {\n    setNodeRef,\n    transform,\n    transition,\n    attributes,\n    listeners,\n    isDragging: isSortableDragging,\n  } = useSortable({\n    id: value,\n    disabled,\n  });\n\n  const { activeId, isColumn } = React.useContext(KanbanContext);\n  const isColumnDragging = activeId ? isColumn(activeId) : false;\n\n  const style = {\n    transition,\n    transform: CSS.Translate.toString(transform),\n  } as React.CSSProperties;\n\n  return (\n    <ColumnContext.Provider value={{ attributes, listeners, isDragging: isColumnDragging, disabled }}>\n      <div\n        data-slot=\"kanban-column\"\n        data-value={value}\n        data-dragging={isSortableDragging}\n        data-disabled={disabled}\n        ref={setNodeRef}\n        style={style}\n        className={cn(\n          'group/kanban-column flex flex-col',\n          isSortableDragging && 'opacity-50',\n          disabled && 'opacity-50',\n          className,\n        )}\n      >\n        {children}\n      </div>\n    </ColumnContext.Provider>\n  );\n}\n\nexport interface KanbanColumnHandleProps {\n  asChild?: boolean;\n  className?: string;\n  children?: React.ReactNode;\n  cursor?: boolean;\n}\n\nfunction KanbanColumnHandle({ asChild, className, children, cursor = true }: KanbanColumnHandleProps) {\n  const { attributes, listeners, isDragging, disabled } = React.useContext(ColumnContext);\n\n  const Comp = asChild ? Slot : 'div';\n\n  return (\n    <Comp\n      data-slot=\"kanban-column-handle\"\n      data-dragging={isDragging}\n      data-disabled={disabled}\n      {...attributes}\n      {...listeners}\n      className={cn(\n        'opacity-0 transition-opacity group-hover/kanban-column:opacity-100',\n        cursor && (isDragging ? '!cursor-grabbing' : '!cursor-grab'),\n        className,\n      )}\n    >\n      {children}\n    </Comp>\n  );\n}\n\nexport interface KanbanItemProps {\n  value: string;\n  asChild?: boolean;\n  className?: string;\n  children: React.ReactNode;\n  disabled?: boolean;\n}\n\nfunction KanbanItem({ value, asChild = false, className, children, disabled }: KanbanItemProps) {\n  const {\n    setNodeRef,\n    transform,\n    transition,\n    attributes,\n    listeners,\n    isDragging: isSortableDragging,\n  } = useSortable({\n    id: value,\n    disabled,\n  });\n\n  const { activeId, isColumn } = React.useContext(KanbanContext);\n  const isItemDragging = activeId ? !isColumn(activeId) : false;\n\n  const style = {\n    transition,\n    transform: CSS.Translate.toString(transform),\n  } as React.CSSProperties;\n\n  const Comp = asChild ? Slot : 'div';\n\n  return (\n    <ItemContext.Provider value={{ listeners, isDragging: isItemDragging, disabled }}>\n      <Comp\n        data-slot=\"kanban-item\"\n        data-value={value}\n        data-dragging={isSortableDragging}\n        data-disabled={disabled}\n        ref={setNodeRef}\n        style={style}\n        {...attributes}\n        className={cn(isSortableDragging && 'opacity-50', disabled && 'opacity-50', className)}\n      >\n        {children}\n      </Comp>\n    </ItemContext.Provider>\n  );\n}\n\nexport interface KanbanItemHandleProps {\n  asChild?: boolean;\n  className?: string;\n  children?: React.ReactNode;\n  cursor?: boolean;\n}\n\nfunction KanbanItemHandle({ asChild, className, children, cursor = true }: KanbanItemHandleProps) {\n  const { listeners, isDragging, disabled } = React.useContext(ItemContext);\n\n  const Comp = asChild ? Slot : 'div';\n\n  return (\n    <Comp\n      data-slot=\"kanban-item-handle\"\n      data-dragging={isDragging}\n      data-disabled={disabled}\n      {...listeners}\n      className={cn(cursor && (isDragging ? '!cursor-grabbing' : '!cursor-grab'), className)}\n    >\n      {children}\n    </Comp>\n  );\n}\n\nexport interface KanbanColumnContentProps {\n  value: string;\n  className?: string;\n  children: React.ReactNode;\n}\n\nfunction KanbanColumnContent({ value, className, children }: KanbanColumnContentProps) {\n  const { columns, getItemId } = React.useContext(KanbanContext);\n\n  const itemIds = React.useMemo(() => columns[value].map(getItemId), [columns, getItemId, value]);\n\n  return (\n    <SortableContext items={itemIds} strategy={verticalListSortingStrategy}>\n      <div data-slot=\"kanban-column-content\" className={cn('flex flex-col gap-2', className)}>\n        {children}\n      </div>\n    </SortableContext>\n  );\n}\n\nexport interface KanbanOverlayProps {\n  className?: string;\n  children?: React.ReactNode | ((params: { value: UniqueIdentifier; variant: 'column' | 'item' }) => React.ReactNode);\n}\n\nfunction KanbanOverlay({ children, className }: KanbanOverlayProps) {\n  const { activeId, isColumn } = React.useContext(KanbanContext);\n  const [dimensions, setDimensions] = React.useState<{ width: number; height: number } | null>(null);\n\n  React.useEffect(() => {\n    if (activeId) {\n      const element = document.querySelector(\n        `[data-slot=\"kanban-${isColumn(activeId) ? 'column' : 'item'}\"][data-value=\"${activeId}\"]`,\n      );\n      if (element) {\n        const rect = element.getBoundingClientRect();\n        setDimensions({ width: rect.width, height: rect.height });\n      }\n    } else {\n      setDimensions(null);\n    }\n  }, [activeId]);\n\n  const style = {\n    width: dimensions?.width,\n    height: dimensions?.height,\n  } as React.CSSProperties;\n\n  const content = React.useMemo(() => {\n    if (!activeId) return null;\n    if (typeof children === 'function') {\n      return children({\n        value: activeId,\n        variant: isColumn(activeId) ? 'column' : 'item',\n      });\n    }\n    return children;\n  }, [activeId, children, isColumn]);\n\n  return (\n    <DragOverlay dropAnimation={dropAnimationConfig}>\n      <div\n        data-slot=\"kanban-overlay\"\n        data-dragging={true}\n        style={style}\n        className={cn('pointer-events-none', className, activeId ? '!cursor-grabbing' : '')}\n      >\n        {content}\n      </div>\n    </DragOverlay>\n  );\n}\n\n// Sortable Item Context\nconst SortableItemContext = React.createContext<{\n  listeners: DraggableSyntheticListeners | undefined;\n  isDragging?: boolean;\n  disabled?: boolean;\n}>({\n  listeners: undefined,\n  isDragging: false,\n  disabled: false,\n});\n\n// Multipurpose Sortable Component\nexport interface SortableRootProps<T> {\n  value: T[];\n  onValueChange: (value: T[]) => void;\n  getItemValue: (item: T) => string;\n  children: React.ReactNode;\n  className?: string;\n  onMove?: (event: { event: DragEndEvent; activeIndex: number; overIndex: number }) => void;\n  strategy?: 'horizontal' | 'vertical' | 'grid';\n  onDragStart?: (event: DragStartEvent) => void;\n  onDragEnd?: (event: DragEndEvent) => void;\n}\n\nfunction Sortable<T>({\n  value,\n  onValueChange,\n  getItemValue,\n  children,\n  className,\n  onMove,\n  strategy = 'vertical',\n  onDragStart,\n  onDragEnd,\n}: SortableRootProps<T>) {\n  const [activeId, setActiveId] = React.useState<UniqueIdentifier | null>(null);\n\n  const sensors = useSensors(\n    useSensor(PointerSensor, {\n      activationConstraint: {\n        distance: 10,\n      },\n    }),\n    useSensor(KeyboardSensor, {\n      coordinateGetter: sortableKeyboardCoordinates,\n    }),\n  );\n\n  const handleDragStart = React.useCallback(\n    (event: DragStartEvent) => {\n      setActiveId(event.active.id);\n      onDragStart?.(event);\n    },\n    [onDragStart],\n  );\n\n  const handleDragEnd = React.useCallback(\n    (event: DragEndEvent) => {\n      const { active, over } = event;\n      setActiveId(null);\n      onDragEnd?.(event);\n\n      if (!over) return;\n\n      // Handle item reordering\n      const activeIndex = value.findIndex((item: T) => getItemValue(item) === active.id);\n      const overIndex = value.findIndex((item: T) => getItemValue(item) === over.id);\n\n      if (activeIndex !== overIndex) {\n        if (onMove) {\n          onMove({ event, activeIndex, overIndex });\n        } else {\n          const newValue = arrayMove(value, activeIndex, overIndex);\n          onValueChange(newValue);\n        }\n      }\n    },\n    [value, getItemValue, onValueChange, onMove, onDragEnd],\n  );\n\n  const getStrategy = () => {\n    switch (strategy) {\n      case 'horizontal':\n        return rectSortingStrategy;\n      case 'grid':\n        return rectSortingStrategy;\n      case 'vertical':\n      default:\n        return verticalListSortingStrategy;\n    }\n  };\n\n  const itemIds = React.useMemo(() => value.map(getItemValue), [value, getItemValue]);\n\n  return (\n    <DndContext sensors={sensors} onDragStart={handleDragStart} onDragEnd={handleDragEnd}>\n      <SortableContext items={itemIds} strategy={getStrategy()}>\n        <div data-slot=\"sortable\" data-dragging={activeId !== null} className={cn(className)}>\n          {children}\n        </div>\n      </SortableContext>\n\n      <DragOverlay>\n        {activeId ? (\n          <div className=\"z-50\">\n            {React.Children.map(children, (child) => {\n              if (React.isValidElement(child) && (child.props as any).value === activeId) {\n                return React.cloneElement(child as React.ReactElement<any>, {\n                  ...(child.props as any),\n                  className: cn((child.props as any).className, 'z-50 shadow-lg'),\n                });\n              }\n              return null;\n            })}\n          </div>\n        ) : null}\n      </DragOverlay>\n    </DndContext>\n  );\n}\n\nexport interface SortableItemProps {\n  value: string;\n  asChild?: boolean;\n  className?: string;\n  children: React.ReactNode;\n  disabled?: boolean;\n}\n\nfunction SortableItem({ value, asChild = false, className, children, disabled }: SortableItemProps) {\n  const {\n    setNodeRef,\n    transform,\n    transition,\n    attributes,\n    listeners,\n    isDragging: isSortableDragging,\n  } = useSortable({\n    id: value,\n    disabled,\n  });\n\n  const style = {\n    transition,\n    transform: CSS.Translate.toString(transform),\n  } as React.CSSProperties;\n\n  const Comp = asChild ? Slot : 'div';\n\n  return (\n    <SortableItemContext.Provider value={{ listeners, isDragging: isSortableDragging, disabled }}>\n      <Comp\n        data-slot=\"sortable-item\"\n        data-value={value}\n        data-dragging={isSortableDragging}\n        data-disabled={disabled}\n        ref={setNodeRef}\n        style={style}\n        {...attributes}\n        className={cn(isSortableDragging && 'opacity-50 z-50', disabled && 'opacity-50', className)}\n      >\n        {children}\n      </Comp>\n    </SortableItemContext.Provider>\n  );\n}\n\nexport interface SortableItemHandleProps {\n  asChild?: boolean;\n  className?: string;\n  children?: React.ReactNode;\n  cursor?: boolean;\n}\n\nfunction SortableItemHandle({ asChild, className, children, cursor = true }: SortableItemHandleProps) {\n  const { listeners, isDragging, disabled } = React.useContext(SortableItemContext);\n\n  const Comp = asChild ? Slot : 'div';\n\n  return (\n    <Comp\n      data-slot=\"sortable-item-handle\"\n      data-dragging={isDragging}\n      data-disabled={disabled}\n      {...listeners}\n      className={cn(cursor && (isDragging ? '!cursor-grabbing' : '!cursor-grab'), className)}\n    >\n      {children}\n    </Comp>\n  );\n}\n\nexport {\n  Kanban,\n  KanbanBoard,\n  KanbanColumn,\n  KanbanColumnHandle,\n  KanbanItem,\n  KanbanItemHandle,\n  KanbanColumnContent,\n  KanbanOverlay,\n  // New multipurpose sortable components\n  Sortable,\n  SortableItem,\n  SortableItemHandle,\n};\n",
      "type": "registry:ui",
      "target": ""
    },
    {
      "path": "registry/default/lib/utils.ts",
      "content": "import { clsx, type ClassValue } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\n/**\n * Merges Tailwind class names, resolving any conflicts.\n *\n * @param inputs - An array of class names to merge.\n * @returns A string of merged and optimized class names.\n */\nexport function cn(...inputs: ClassValue[]): string {\n  return twMerge(clsx(inputs));\n}\n",
      "type": "registry:lib",
      "target": ""
    }
  ]
}
