{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "twinkle-grid-mask-rounded",
  "type": "registry:component",
  "dependencies": ["class-variance-authority", "lucide-react", "radix-ui"],
  "registryDependencies": ["https://reui.io/r/twinkle-grid.json"],
  "files": [
    {
      "path": "registry/default/components/twinkle-grid/mask-rounded.tsx",
      "content": "import { TwinkleGrid } from '@/registry/default/ui/twinkle-grid';\n\nexport default function TwinkleGridMaskRounded() {\n  return (\n    <div className=\"relative h-96 w-full overflow-hidden rounded-lg border bg-background\">\n      <TwinkleGrid\n        className=\"relative inset-0 z-0 [mask-image:radial-gradient(450px_circle_at_center,white,transparent)]\"\n        squareSize={6}\n        gridGap={4}\n        color=\"#60A5FA\"\n        maxOpacity={0.5}\n        flickerChance={0.1}\n        height={800}\n        width={800}\n      />\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/default/ui/twinkle-grid.tsx",
      "content": "'use client';\n\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { cn } from '@/lib/utils';\n\ninterface TwinkleGridProps extends React.HTMLAttributes<HTMLDivElement> {\n  squareSize?: number;\n  gridGap?: number;\n  flickerChance?: number;\n  color?: string;\n  width?: number;\n  height?: number;\n  className?: string;\n  maxOpacity?: number;\n}\n\nexport const TwinkleGrid: React.FC<TwinkleGridProps> = ({\n  squareSize = 4,\n  gridGap = 6,\n  flickerChance = 0.3,\n  color = 'rgb(0, 0, 0)',\n  width,\n  height,\n  className,\n  maxOpacity = 0.3,\n  ...props\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [isInView, setIsInView] = useState(false);\n  const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 });\n\n  // Convert color to RGBA\n  const memoizedColor = useMemo(() => {\n    const toRGBA = (color: string) => {\n      if (typeof window === 'undefined') {\n        return `rgba(0, 0, 0,`;\n      }\n      const canvas = document.createElement('canvas');\n      canvas.width = canvas.height = 1;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) return 'rgba(255, 0, 0,';\n      ctx.fillStyle = color;\n      ctx.fillRect(0, 0, 1, 1);\n      const [r, g, b] = Array.from(ctx.getImageData(0, 0, 1, 1).data);\n      return `rgba(${r}, ${g}, ${b},`;\n    };\n    return toRGBA(color);\n  }, [color]);\n\n  const setupCanvas = useCallback(\n    (canvas: HTMLCanvasElement, width: number, height: number) => {\n      // Set canvas size with device pixel ratio\n      const dpr = window.devicePixelRatio || 1;\n      // Set canvas width and height\n      canvas.width = width * dpr;\n      canvas.height = height * dpr;\n      canvas.style.width = `${width}px`;\n      canvas.style.height = `${height}px`;\n      // Calculate grid dimensions\n      const cols = Math.floor(width / (squareSize + gridGap));\n      const rows = Math.floor(height / (squareSize + gridGap));\n      // Initialize squares opacity\n      const squares = new Float32Array(cols * rows);\n      for (let i = 0; i < squares.length; i++) {\n        squares[i] = Math.random() * maxOpacity;\n      }\n\n      return { cols, rows, squares, dpr };\n    },\n    [squareSize, gridGap, maxOpacity],\n  );\n\n  // Update squares opacity\n  const updateSquares = useCallback(\n    (squares: Float32Array, deltaTime: number) => {\n      // Update squares opacity\n      for (let i = 0; i < squares.length; i++) {\n        if (Math.random() < flickerChance * deltaTime) {\n          squares[i] = Math.random() * maxOpacity;\n        }\n      }\n    },\n    [flickerChance, maxOpacity],\n  );\n\n  // Draw grid\n  const drawGrid = useCallback(\n    (\n      ctx: CanvasRenderingContext2D,\n      width: number,\n      height: number,\n      cols: number,\n      rows: number,\n      squares: Float32Array,\n      dpr: number,\n    ) => {\n      ctx.clearRect(0, 0, width, height);\n      ctx.fillStyle = 'transparent';\n      ctx.fillRect(0, 0, width, height);\n\n      for (let i = 0; i < cols; i++) {\n        for (let j = 0; j < rows; j++) {\n          const opacity = squares[i * rows + j];\n          ctx.fillStyle = `${memoizedColor}${opacity})`;\n          ctx.fillRect(\n            i * (squareSize + gridGap) * dpr,\n            j * (squareSize + gridGap) * dpr,\n            squareSize * dpr,\n            squareSize * dpr,\n          );\n        }\n      }\n    },\n    [memoizedColor, squareSize, gridGap],\n  );\n\n  // Setup canvas and animation\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const container = containerRef.current;\n    if (!canvas || !container) return;\n\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    let animationFrameId: number;\n    let gridParams: ReturnType<typeof setupCanvas>;\n\n    const updateCanvasSize = () => {\n      const newWidth = width || container.clientWidth;\n      const newHeight = height || container.clientHeight;\n      setCanvasSize({ width: newWidth, height: newHeight });\n      gridParams = setupCanvas(canvas, newWidth, newHeight);\n    };\n\n    updateCanvasSize();\n\n    let lastTime = 0;\n    const animate = (time: number) => {\n      if (!isInView) return;\n\n      const deltaTime = (time - lastTime) / 1000;\n      lastTime = time;\n\n      updateSquares(gridParams.squares, deltaTime);\n      drawGrid(ctx, canvas.width, canvas.height, gridParams.cols, gridParams.rows, gridParams.squares, gridParams.dpr);\n      animationFrameId = requestAnimationFrame(animate);\n    };\n\n    const resizeObserver = new ResizeObserver(() => {\n      updateCanvasSize();\n    });\n\n    resizeObserver.observe(container);\n\n    const intersectionObserver = new IntersectionObserver(\n      ([entry]) => {\n        setIsInView(entry.isIntersecting);\n      },\n      { threshold: 0 },\n    );\n\n    intersectionObserver.observe(canvas);\n\n    if (isInView) {\n      animationFrameId = requestAnimationFrame(animate);\n    }\n\n    return () => {\n      cancelAnimationFrame(animationFrameId);\n      resizeObserver.disconnect();\n      intersectionObserver.disconnect();\n    };\n  }, [setupCanvas, updateSquares, drawGrid, width, height, isInView]);\n\n  return (\n    <div ref={containerRef} className={cn(`h-full w-full ${className}`)} {...props}>\n      <canvas\n        ref={canvasRef}\n        className=\"pointer-events-none\"\n        style={{\n          width: canvasSize.width,\n          height: canvasSize.height,\n        }}\n      />\n    </div>\n  );\n};\n",
      "type": "registry:ui",
      "target": ""
    }
  ]
}
